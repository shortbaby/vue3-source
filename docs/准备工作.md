---
id: doc3
title: 学习准备
sidebar_label: 学习准备
---

在上一节中，我们讲到在学习vue3之前，我们需要先了解Proxy，因为vue3的响应式数据就是依靠Proxy去实现,相对于vue2.0 中的 Object.defineProperty()，Proxy提供了更强大的能力进行数据双向绑定。

我们知道双向的数据绑定是依靠数据劫持去实现的，所谓数据劫持就是在访问或者修改对象的某个属性时，通过一段代码拦截这个行为，进行额外的操作或者修改返回结果。Object.defineProperty 在进行数据劫持的时候会有以下几个问题：
1. 不能监听数组的变化
2. 必须遍历对象的每个属性
3. 必须深层遍历嵌套的对象
  
在vue2.0中 为了解决已上几个问题，对于数组变化通过修改原来数组的方法定义为变异方法 (mutation method)把这些方法重写来实现数组的劫持，当一个对象为深层嵌套的时候,必须进行逐层遍历，进行多次调用Object.keys，直到把每个对象的每个属性都调用 Object.defineProperty为止。

相比较于Object.defineProperty，Proxy可以直接监听对象而非属性，也可以直接监听数组的变化。Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。
Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改。

一个简单的Proxy例子：
```javascript
const obj = { a: 1111, b: { c: 22222} }
const newObj = new Proxy(obj, {
  get: function(target, key, receiver) {
    console.log(`getting ${key}!`);
    return Reflect.get(target, key, receiver);
  },
  set: function(target, key, value, receiver) {
    console.log(target, key, value, receiver);
    return Reflect.set(target, key, value, receiver);
  },
});
newObj.a = 3333;
newObj.b.c = 4444;

/* 输出结果 */
/* 
  { a: 1111, b: { c: 22222 } }
  a 3333
  Proxy: { a: 1111, b: { c: 22222 } }
  getting b!
*/
```
通过例子我们可以清楚的知道，当读取newObj.a的时候会触发get函数，在get函数里我们可以触发我们想要做的操作。当设置newObj.a值得时候，就会触发set函数也可以实现数据劫持的功能。但是我们也发现Proxy也只能代理嵌套对象的时候只会代理第一层的属性，对于深层次的属性是默认不代理的。所以在实际的运用中，当访问深层的对象属性的时候，如果属性值是对象类型的话，需要将其再进行Proxy代理返回，这样就实现了深层次对象的数据劫持。Proxy是vue3.0中最核心的技术之一、数据更新触发试图更新就是依靠Proxy实现的。后面介绍的源码包@vue/reactivity就大量的运用了Proxy实现了响应式数据。





